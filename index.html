<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Steam Backlog</title>
<style>
    body {
        background-color: #1e1e1e;
        color: #fff;
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
    }
    header {
        padding: 20px;
        text-align: center;
    }
    input, button, select {
        padding: 10px;
        margin: 5px;
        border-radius: 5px;
        border: none;
    }
    #results {
        max-width: 900px;
        margin: 20px auto;
    }
    .game {
        display: flex;
        align-items: center;
        background: #2b2b2b;
        margin: 10px 0;
        padding: 10px;
        border-radius: 8px;
    }
    .game img {
        width: 100px;
        height: auto;
        border-radius: 5px;
        margin-right: 15px;
    }
    .spinner {
        text-align: center;
        padding: 20px;
    }
</style>
</head>
<body>
<header>
    <h1>Steam Backlog</h1>
    <input type="text" id="steamId" placeholder="Enter Steam ID or Vanity Name">
    <button onclick="loadBacklog()">Load Backlog</button>
    <input type="text" id="searchBox" placeholder="Search games" oninput="filterGames()">
    <select id="genreFilter" multiple size="5" onchange="filterGames()"></select>
</header>

<div id="results"></div>

<script>
const workerURL = "blast000.jackedwardrose23.workers.dev"; // Your Cloudflare Worker URL

async function fetchJSON(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
}

async function resolveVanity(name) {
    const data = await fetchJSON(`${workerURL}?endpoint=vanity&vanity=${encodeURIComponent(name)}`);
    if (data.response.success === 1) {
        return data.response.steamid;
    } else {
        throw new Error("Vanity name not found");
    }
}

async function loadBacklog() {
    const idInput = document.getElementById("steamId").value.trim();
    const resultsDiv = document.getElementById("results");
    resultsDiv.innerHTML = `<div class="spinner">Loading backlog...</div>`;
    document.getElementById("genreFilter").innerHTML = "";

    let steamId = idInput;
    if (isNaN(idInput)) {
        steamId = await resolveVanity(idInput);
    }

    try {
        const data = await fetchJSON(`${workerURL}?endpoint=games&steamid=${steamId}`);
        const games = data.response.games;

        let genreSet = new Set();
        resultsDiv.innerHTML = "";
        for (const g of games) {
            const storeData = await fetchJSON(`https://store.steampowered.com/api/appdetails?appids=${g.appid}`);
            if (storeData && storeData[g.appid] && storeData[g.appid].success) {
                const gameInfo = storeData[g.appid].data;
                const genres = gameInfo.genres ? gameInfo.genres.map(gen => gen.description) : [];
                genres.forEach(gen => genreSet.add(gen));

                const gameEl = document.createElement("div");
                gameEl.className = "game";
                gameEl.dataset.name = g.name.toLowerCase();
                gameEl.dataset.genres = genres.join(",").toLowerCase();

                const img = document.createElement("img");
                img.src = gameInfo.header_image || `https://cdn.cloudflare.steamstatic.com/steam/apps/${g.appid}/header.jpg`;
                img.alt = g.name;

                const title = document.createElement("div");
                title.innerHTML = `<strong>${g.name}</strong><br><small>${genres.join(", ")}</small>`;

                gameEl.appendChild(img);
                gameEl.appendChild(title);
                resultsDiv.appendChild(gameEl);
            }
        }

        // Populate genre filter
        genreSet.forEach(gen => {
            const opt = document.createElement("option");
            opt.value = gen;
            opt.textContent = gen;
            document.getElementById("genreFilter").appendChild(opt);
        });

    } catch (err) {
        resultsDiv.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
    }
}

function filterGames() {
    const search = document.getElementById("searchBox").value.toLowerCase();
    const selectedGenres = Array.from(document.getElementById("genreFilter").selectedOptions).map(o => o.value.toLowerCase());

    document.querySelectorAll(".game").forEach(game => {
        const matchesSearch = game.dataset.name.includes(search);
        const matchesGenre = selectedGenres.length === 0 || selectedGenres.some(gen => game.dataset.genres.includes(gen));
        game.style.display = matchesSearch && matchesGenre ? "flex" : "none";
    });
}
</script>
</body>
</html>

